<hr>
<h2>step: 1</h2>
<h1>Memory</h1>
<p><strong>Keid is a memory-safe language.</strong> Unless there is explicitly unsafe code (e.g. calling an external C function), a Keid program should never have a segmentation fault.</p>
<h2>Object Reference Counting.</h2>
<p>The Keid runtime manages the allocation and freeing of objects stored in the heap. Garbage collectors are a common implementation of determining when memory should be freed. This is how languages like Java, C#, Go, and many other languages free memory.</p>
<p>Instead of garbage collection, Keid uses Object Reference Counting (ORC) in its memory model. This is used in languages like Swift and Objective-C.</p>
<p>Each object in the heap has a metadata value representing how many active references there are to the object.</p>
<p>When an object enters a new context, its reference count is increased by one.</p>
<p>When an object exits the context, its reference count is decreased by one. If the result is equal to zero, meaning that there are zero references to the object, its <a href="#Destructors">destructor</a> is invoked and then its memory is freed.</p>
<h2>Destructors</h2>
<p>Destructors are functions that are invoked on every object immediately before they are freed.
The compiler automatically generates destructors to free its fields.
In Keid you can define a destructor that will be invoked before the compiler-generated part of the destructor executes.</p>
<pre><code class="language-keid">class HandleHolder {
    handle: Pointer&lt;void&gt;

    destructor {
        // call into the external C library to close the handle
        unsafe {
            libhandle_close(this.handle)
        }
    }
}
</code></pre>
